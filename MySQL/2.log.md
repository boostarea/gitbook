# redo log、binlog

## 更新语句执行流程

1. 清除执行表上，所有缓存结果。
2. 分析器确定是一条更新语句。
3. 优化器决定是否使用索引。
4. 执行器负责具体执行。

## redo log（InnoDB）

1. 设计原因：如果每次更新操作，都写进磁盘，整个过程的成本很高。
2. WAL（Write-Ahead Logging）先写日志，等不忙时候再写磁盘。
3. 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到redo log里，并更新内存，更新操作就算完成，同时，引擎会在适当时候，将这个操作写到磁盘。
4. 适当时候： 
   - redo log是固定大小，writepoint与checkpoint之间为空部分，当两个位置相等，得先擦掉一些记录，推进checkpoint。
   - redo log未满，待系统不忙时，自动写入磁盘。
5. Crash-safe: 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。

## binliog

1.  属于server层日志，最开始MySQL并没有InnoDB引擎，MyISAM并没有crash-safe能力。
2. redo log是物理日志，记录了做了什么修改；binlog是逻辑日志，记录语句原始逻辑。
3. redo log是循环写，空间固定；binlog是追加写入。

## 两阶段提交

### 避免数据库状态不一致性，两个日志类原子性。

1. 执行器先调用引擎接口，从内存中获取数据，数据页若不在内存，则从磁盘先读入内存；
2. 执行器更新数据，调用引擎写入接口；
3. 引擎将数据更新到内存，并记录到redo log里，此时redo log状态为prepare；
4. 执行器生成binlog，并写入磁盘；
5. 执行器调用引擎提交事务接口，更改redo log状态为commit；

## 数据库恢复

1. 先找到最近一次全量备份；
2. 再从未全量备份时间开始，将binlog取出来，执行语句。

